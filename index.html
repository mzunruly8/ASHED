<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ASHED</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;500;700&display=swap');
        
        body {
            background: radial-gradient(circle at center, #0f172a 0%, #020617 100%);
            color: #f8fafc;
            font-family: 'Space Grotesk', sans-serif;
            margin: 0;
            overflow: hidden;
            touch-action: none;
            height: 100dvh;
        }

        .tile {
            background: rgba(15, 23, 42, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            position: relative;
            border-radius: 8px;
            transition: transform 0.1s ease;
        }

        .socket {
            width: 85%;
            height: 85%;
            background: #1e293b;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
        }

        .mini-circle {
            width: 45%;
            height: 45%;
            border-radius: 50%;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            color: white;
            box-shadow: 0 0 10px transparent;
        }

        .indicator {
            font-size: 10px;
            pointer-events: none;
            opacity: 0.8;
        }

        .tile.selected {
            transform: scale(0.9);
        }

        .tile.selected .mini-circle {
            width: 100%;
            height: 100%;
            border-radius: 20%;
            box-shadow: 0 0 15px currentColor;
        }

        .tile.selected .indicator {
            font-size: 16px;
            opacity: 1;
        }

        .shake {
            animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
        }

        @keyframes shake {
            10%, 90% { transform: translate3d(-2px, 0, 0); }
            20%, 80% { transform: translate3d(3px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-5px, 0, 0); }
            40%, 60% { transform: translate3d(5px, 0, 0); }
        }

        .floating-text {
            position: absolute;
            pointer-events: none;
            animation: floatUp 0.8s ease-out forwards;
            font-size: 20px;
            font-weight: 800;
            z-index: 100;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }

        @keyframes floatUp {
            0% { transform: translate(-50%, 0); opacity: 1; }
            100% { transform: translate(-50%, -80px); opacity: 0; }
        }

        #connectionCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 10;
        }

        .hp-bar-container {
            background: #1e293b;
            border-radius: 4px;
            height: 12px;
            overflow: hidden;
            border: 1px solid #334155;
        }

        .btn-active {
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.4);
            transform: translateY(-1px);
        }
    </style>
</head>
<body class="flex flex-col items-center justify-between py-6 px-4">

    <!-- Start Screen -->
    <div id="start-screen" class="flex flex-col items-center justify-center h-full gap-8">
        <div class="text-center">
            <h1 class="text-8xl font-black tracking-tighter text-sky-500 italic">ASHED</h1>
            <p class="text-slate-500 text-xs mt-4 font-bold tracking-[0.3em] uppercase opacity-60">UNRULY CORE ENGINE</p>
        </div>
        <button onclick="startGame()" class="bg-sky-600 hover:bg-sky-500 text-white font-black px-16 py-5 rounded-sm skew-x-[-10deg] transition-all active:scale-90">
            INITIATE
        </button>
    </div>

    <!-- Battle Screen -->
    <div id="battle-screen" class="hidden w-full max-w-md flex flex-col gap-4">
        
        <!-- Enemy Section -->
        <div class="bg-slate-900/40 p-4 border-l-4 border-rose-600 backdrop-blur-sm">
            <div class="flex justify-between items-end mb-2">
                <span id="enemy-name" class="text-lg font-black text-rose-500 uppercase tracking-tighter">Void Weaver</span>
                <span class="text-[10px] text-slate-500 font-bold">LVL <span id="enemy-level">1</span></span>
            </div>
            <div class="hp-bar-container">
                <div id="enemy-hp-bar" class="h-full bg-rose-600 transition-all duration-300" style="width: 100%"></div>
            </div>
            <div class="flex justify-between text-[10px] font-bold text-slate-400 mt-2 uppercase">
                <span id="enemy-hp-text">100 / 100</span>
                <span>Burst In: <span id="enemy-timer" class="text-rose-500">3</span></span>
            </div>
        </div>

        <!-- The Grid -->
        <div class="relative aspect-square w-full bg-slate-950/80 rounded-sm p-1 border border-slate-800 grid grid-cols-7 grid-rows-7 gap-1" id="grid-container">
            <canvas id="connectionCanvas"></canvas>
        </div>

        <!-- Player Section -->
        <div class="bg-slate-900/40 p-4 border-r-4 border-sky-500 backdrop-blur-sm space-y-4">
            <div class="flex justify-between items-center text-[10px] font-black text-sky-500 tracking-widest">
                <span>SYSTEM STATUS</span>
                <span>LV <span id="player-level">1</span></span>
            </div>
            
            <div class="hp-bar-container">
                <div id="player-hp-bar" class="h-full bg-sky-500 transition-all duration-300" style="width: 100%"></div>
            </div>
            
            <div class="grid grid-cols-2 gap-3">
                <button id="skill-1" onclick="useSkill(0)" class="bg-slate-800/50 border border-slate-700 py-3 text-[10px] font-black uppercase text-slate-500 transition-all rounded-sm">
                    Smite (15 E)
                </button>
                <button id="skill-2" onclick="useSkill(1)" class="bg-slate-800/50 border border-slate-700 py-3 text-[10px] font-black uppercase text-slate-500 transition-all rounded-sm">
                    Reboot (10 E)
                </button>
            </div>

            <div class="flex justify-between items-center font-black">
                <div class="text-[10px] text-slate-500 uppercase">Energy: <span id="player-energy" class="text-amber-500 text-sm ml-1">0</span></div>
                <div class="text-[10px] text-slate-500 uppercase">Shield: <span id="player-def" class="text-sky-400 text-sm ml-1">0</span></div>
            </div>
        </div>
    </div>

    <!-- End Screen -->
    <div id="end-screen" class="hidden flex flex-col items-center justify-center h-full gap-8">
        <h2 id="end-title" class="text-6xl font-black italic text-sky-500">VICTORY</h2>
        <button onclick="restartGame()" class="bg-white text-black font-black px-12 py-4 rounded-sm skew-x-[-10deg]">REBOOT</button>
    </div>

    <script>
        const GRID_SIZE = 7;
        const TILE_TYPES = ['red', 'blue', 'green', 'yellow'];
        const TILE_COLORS = { red: '#f43f5e', blue: '#0ea5e9', green: '#10b981', yellow: '#f59e0b' };
        const TILE_LETTERS = { red: 'A', blue: 'S', green: 'H', yellow: 'E' };
        
        let gameState = {
            player: { hp: 80, maxHp: 80, level: 1, energy: 0, def: 0 },
            enemy: { hp: 150, maxHp: 150, level: 1, timer: 3, maxTimer: 3, atk: 18 },
            grid: [], isDragging: false, selectedTiles: [], isProcessing: false
        };

        const gridContainer = document.getElementById('grid-container');
        const canvas = document.getElementById('connectionCanvas');

        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('battle-screen').classList.remove('hidden');
            initGrid();
            updateUI();
            window.addEventListener('resize', resizeCanvas);
            setTimeout(resizeCanvas, 50);
        }

        function initGrid() {
            gridContainer.querySelectorAll('.tile').forEach(t => t.remove());
            gameState.grid = [];
            for (let r = 0; r < GRID_SIZE; r++) {
                gameState.grid[r] = [];
                for (let c = 0; c < GRID_SIZE; c++) createTile(r, c);
            }
        }

        function createTile(r, c) {
            const type = TILE_TYPES[Math.floor(Math.random() * TILE_TYPES.length)];
            const tileEl = document.createElement('div');
            tileEl.className = 'tile';
            tileEl.dataset.row = r;
            tileEl.dataset.col = c;
            tileEl.dataset.type = type;

            const socket = document.createElement('div');
            socket.className = 'socket';
            
            const miniCircle = document.createElement('div');
            miniCircle.className = 'mini-circle';
            miniCircle.style.backgroundColor = TILE_COLORS[type];
            miniCircle.style.color = TILE_COLORS[type];
            
            const letter = document.createElement('span');
            letter.className = 'indicator';
            letter.innerText = TILE_LETTERS[type];
            
            miniCircle.appendChild(letter);
            socket.appendChild(miniCircle);
            tileEl.appendChild(socket);

            // Input Listeners
            tileEl.addEventListener('touchstart', (e) => { e.preventDefault(); startDrag(r, c); }, {passive: false});
            tileEl.addEventListener('mousedown', (e) => { startDrag(r, c); });

            gridContainer.appendChild(tileEl);
            gameState.grid[r][c] = { type, el: tileEl };
        }

        // Global Move Handlers for Mobile
        window.addEventListener('touchmove', (e) => {
            if (!gameState.isDragging) return;
            const touch = e.touches[0];
            const el = document.elementFromPoint(touch.clientX, touch.clientY);
            const tile = el?.closest('.tile');
            if (tile) continueDrag(parseInt(tile.dataset.row), parseInt(tile.dataset.col));
        }, {passive: false});

        window.addEventListener('mousemove', (e) => {
            if (!gameState.isDragging) return;
            const tile = e.target.closest('.tile');
            if (tile) continueDrag(parseInt(tile.dataset.row), parseInt(tile.dataset.col));
        });

        window.addEventListener('touchend', endDrag);
        window.addEventListener('mouseup', endDrag);

        function startDrag(r, c) {
            if (gameState.isProcessing) return;
            gameState.isDragging = true;
            gameState.selectedTiles = [{ r, c }];
            gameState.grid[r][c].el.classList.add('selected');
            drawLines();
        }

        function continueDrag(r, c) {
            if (!gameState.isDragging || gameState.isProcessing) return;
            const last = gameState.selectedTiles[gameState.selectedTiles.length - 1];
            
            // Undo logic
            if (gameState.selectedTiles.length > 1) {
                const prev = gameState.selectedTiles[gameState.selectedTiles.length - 2];
                if (prev.r === r && prev.c === c) {
                    gameState.grid[last.r][last.c].el.classList.remove('selected');
                    gameState.selectedTiles.pop();
                    drawLines();
                    return;
                }
            }

            if (last.r === r && last.c === c) return;

            const isAdj = Math.abs(last.r - r) <= 1 && Math.abs(last.c - c) <= 1;
            const isSame = gameState.grid[r][c].type === gameState.grid[last.r][last.c].type;
            const isNew = !gameState.selectedTiles.some(t => t.r === r && t.c === c);

            if (isAdj && isSame && isNew) {
                gameState.selectedTiles.push({ r, c });
                gameState.grid[r][c].el.classList.add('selected');
                drawLines();
            }
        }

        async function endDrag() {
            if (!gameState.isDragging) return;
            gameState.isDragging = false;
            
            if (gameState.selectedTiles.length >= 3) {
                await processSelection();
            } else {
                gameState.selectedTiles.forEach(t => gameState.grid[t.r][t.c].el.classList.remove('selected'));
                gameState.selectedTiles = [];
                clearLines();
            }
        }

        async function processSelection() {
            gameState.isProcessing = true;
            const count = gameState.selectedTiles.length;
            const type = gameState.grid[gameState.selectedTiles[0].r][gameState.selectedTiles[0].c].type;
            
            // Apply Effects
            if (type === 'red') dealDamage(count * 7);
            else if (type === 'blue') {
                gameState.player.def += (count * 4);
                showFloatingText(`SHIELD +${count*4}`, '#0ea5e9');
            } else if (type === 'green') {
                const heal = count * 5;
                gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + heal);
                showFloatingText(`RECOVER +${heal}`, '#10b981');
            } else if (type === 'yellow') {
                gameState.player.energy += (count * 3);
                showFloatingText(`CORE +${count*3}`, '#f59e0b');
            }

            // Cleanup
            gameState.selectedTiles.forEach(t => {
                gameState.grid[t.r][t.c].el.style.opacity = '0';
                gameState.grid[t.r][t.c].el.style.transform = 'scale(0)';
            });

            await new Promise(r => setTimeout(r, 250));
            initGrid();
            clearLines();
            gameState.selectedTiles = [];

            // Enemy Turn Logic
            gameState.enemy.timer--;
            if (gameState.enemy.timer <= 0) {
                await enemyAttack();
                gameState.enemy.timer = gameState.enemy.maxTimer;
            }
            
            gameState.isProcessing = false;
            updateUI();
            
            if (gameState.player.hp <= 0) showEndScreen(false);
            if (gameState.enemy.hp <= 0) levelUp();
        }

        function dealDamage(amount) {
            gameState.enemy.hp -= amount;
            showFloatingText(`-${amount}`, '#f43f5e', true);
        }

        async function enemyAttack() {
            const hit = Math.max(1, gameState.enemy.atk - gameState.player.def);
            gameState.player.hp -= hit;
            gameState.player.def = 0;
            showFloatingText(`CRIT -${hit}`, '#fff');
            document.body.classList.add('shake');
            setTimeout(() => document.body.classList.remove('shake'), 400);
            updateUI();
        }

        function levelUp() {
            gameState.player.level++;
            gameState.player.maxHp += 30;
            gameState.player.hp = gameState.player.maxHp;
            gameState.enemy.level++;
            gameState.enemy.maxHp += 80;
            gameState.enemy.hp = gameState.enemy.maxHp;
            gameState.enemy.atk += 8;
            showFloatingText("LEVEL UP", "#38bdf8");
            updateUI();
        }

        function useSkill(idx) {
            if (gameState.isProcessing) return;
            if (idx === 0 && gameState.player.energy >= 15) {
                gameState.player.energy -= 15;
                dealDamage(60 + (gameState.player.level * 15));
                updateUI();
            } else if (idx === 1 && gameState.player.energy >= 10) {
                gameState.player.energy -= 10;
                const h = 50 + (gameState.player.level * 10);
                gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + h);
                showFloatingText(`REBOOT +${h}`, '#10b981');
                updateUI();
            }
        }

        function updateUI() {
            const eHpPct = (gameState.enemy.hp / gameState.enemy.maxHp) * 100;
            const pHpPct = (gameState.player.hp / gameState.player.maxHp) * 100;
            
            document.getElementById('enemy-hp-bar').style.width = Math.max(0, eHpPct) + '%';
            document.getElementById('enemy-hp-text').innerText = `${Math.ceil(gameState.enemy.hp)} / ${gameState.enemy.maxHp}`;
            document.getElementById('enemy-timer').innerText = gameState.enemy.timer;
            document.getElementById('enemy-level').innerText = gameState.enemy.level;

            document.getElementById('player-hp-bar').style.width = Math.max(0, pHpPct) + '%';
            document.getElementById('player-energy').innerText = gameState.player.energy;
            document.getElementById('player-def').innerText = gameState.player.def;
            document.getElementById('player-level').innerText = gameState.player.level;

            // Skill Button States
            const b1 = document.getElementById('skill-1');
            const b2 = document.getElementById('skill-2');
            
            if (gameState.player.energy >= 15) b1.className = "bg-sky-600 border border-sky-400 py-3 text-[10px] font-black uppercase text-white rounded-sm btn-active";
            else b1.className = "bg-slate-800/50 border border-slate-700 py-3 text-[10px] font-black uppercase text-slate-500 rounded-sm opacity-50";
            
            if (gameState.player.energy >= 10) b2.className = "bg-emerald-600 border border-emerald-400 py-3 text-[10px] font-black uppercase text-white rounded-sm btn-active";
            else b2.className = "bg-slate-800/50 border border-slate-700 py-3 text-[10px] font-black uppercase text-slate-500 rounded-sm opacity-50";
        }

        function showFloatingText(text, color, isEnemy = false) {
            const div = document.createElement('div');
            div.className = 'floating-text';
            div.innerText = text;
            div.style.color = color;
            div.style.left = '50%';
            div.style.top = isEnemy ? '25%' : '75%';
            document.body.appendChild(div);
            setTimeout(() => div.remove(), 800);
        }

        function resizeCanvas() {
            const rect = gridContainer.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            drawLines();
        }

        function clearLines() {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function drawLines() {
            if (gameState.selectedTiles.length < 1) return;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.beginPath();
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            const firstTileType = gameState.grid[gameState.selectedTiles[0].r][gameState.selectedTiles[0].c].type;
            ctx.strokeStyle = TILE_COLORS[firstTileType];
            ctx.shadowBlur = 10;
            ctx.shadowColor = TILE_COLORS[firstTileType];

            const rect = gridContainer.getBoundingClientRect();
            gameState.selectedTiles.forEach((p, i) => {
                const tRect = gameState.grid[p.r][p.c].el.getBoundingClientRect();
                const x = (tRect.left - rect.left) + tRect.width / 2;
                const y = (tRect.top - rect.top) + tRect.height / 2;
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            });
            ctx.stroke();
        }

        function showEndScreen(victory) {
            document.getElementById('battle-screen').classList.add('hidden');
            document.getElementById('end-screen').classList.remove('hidden');
            document.getElementById('end-title').innerText = victory ? "ASHED VICTORY" : "CRITICAL FAILURE";
            document.getElementById('end-title').className = victory ? "text-6xl font-black italic text-sky-500" : "text-6xl font-black italic text-rose-600";
        }

        function restartGame() { location.reload(); }
    </script>
</body>
</html>

